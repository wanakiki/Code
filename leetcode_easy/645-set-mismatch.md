## 645. 错误的集合 

2021-07-04 16:50:01

### 题目

集合 ``s`` 包含从 ``1`` 到 ``n`` 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 **丢失了一个数字** 并且 
**有一个数字重复** 。

给定一个数组 ``nums`` 代表了集合 ``S`` 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

 

**示例 1：**

```
输入：nums = [1,2,2,4]
输出：[2,3]
```

**示例 2：**

```
输入：nums = [1,1]
输出：[1,2]
```

 

**提示：**


- ``2 <= nums.length <= 10<sup>4</sup>``
- ``1 <= nums[i] <= 10<sup>4</sup>``



[LeetCode链接](https://leetcode-cn.com/problems/set-mismatch/)

### 思路及代码

数组下标做索引，进行原地存储。过程中累加数组的和并记录重复数据。需要注意的是数据的范围是[1,n]，不存在零，需要对值为n的情况做特殊处理。

```cpp
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        int count = 0, double_num = 0;
        int n = nums.size();
        int sum_num = (n * (n + 1)) / 2;

        for(int i = 0; i < n; i++){
            int cur = nums[i] % n;
            count += cur == 0 ? n : cur;
            if(nums[cur] > n){
                double_num = cur == 0 ? n : cur;
            }
            nums[cur] += n;
        }

        int left_num = sum_num - count + double_num;
        return {double_num, left_num};
    }
};
```

自己做题的时候没想到位运算的实现方式，查看官方题解之后感觉位运算反而显得有些麻烦：

位运算获取值的思想是利用异或的运算特性以及数据出现频率的奇偶性对数据进行提取。初始情况下，设重复数据为x，未出现数据为y，则x出现次数为2，y出现次数为0，其余数字出现次数为1，x与y的奇偶性相同。

将原数组异或结果与新的$1\sim n$数据进行异或，则亦或结果为$x\oplus y$。由于x与y不同，上述结果必然不为零，则可以根据该结果的最低位的1对原始数据进行区分，分为两组。

之后将每组数据与$1\sim n$分为两组的结果进行异或，则两组数据的亦或结果为x与y。但此时并不知道哪个数据是重复的数据，因而还需要再次遍历原始数组进行查找。