## 137. 只出现一次的数字 II

2021-04-30 11:52:37        

### 题目

给你一个整数数组 ``nums`` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**。请你找出并返回那个只出现了一次的元素。

 

**示例 1：**

```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**

```
输入：nums = [0,1,0,1,0,1,99]
输出：99
```

 

**提示：**


- ``1 <= nums.length <= 3 * 10<sup>4</sup>``
- ``-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1``
- ``nums`` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**


 

**进阶：** 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？


[LeetCode链接](https://leetcode-cn.com/problems/single-number-ii/)

### 思路及代码

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        vector<int> count(32, 0);
        for(auto n : nums){
            for(int i = 0; i < 32; i++){
                if(n == 0){
                    break;
                }
                else{
                    count[i] += n & 1;
                    n >>= 1;
                }
            }
        }

        int res = 0;
        for(int i = 0; i < 32; i++){
            if(count[i] % 3){
                res |= (1 << i);    // 左移方法得到各位数值，不需要额外考虑复数情况
            }
        }
        return res;
    }
};
```

遍历数组，统计每个二进制位中1出现的次数，该次数模3后如果为1代表出现一次的元素在该位为1。过程中需要考虑复数的存在，在计算结果时最好使用位运算。

不使用额外空间的算法需要用到数字逻辑相关知识，通过逻辑门实现每位二进制中1出现的次数。