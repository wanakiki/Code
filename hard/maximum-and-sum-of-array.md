## 2291. 数组的最大与和

2022-02-13 15:41:05

### 题目

给你一个长度为 ``n`` 的整数数组 ``nums`` 和一个整数 ``numSlots`` ，满足``2 * numSlots >= n`` 。总共有 ``numSlots`` 个篮 
子，编号为 ``1`` 到 ``numSlots`` 。

你需要把所有 ``n`` 个整数分到这些篮子中，且每个篮子 **至多** 有 2 个整数。一种分配方案的 **与和** 定义为每个数与它所在篮
子编号的 **按位与运算** 结果之和。


- 比方说，将数字 ``[1, 3]`` 放入篮子 **``1``** 中，``[4, 6]`` 放入篮子 **``2``** 中，这个方案的与和为 
``(1 AND **1**) + (3 AND **1**) + (4 AND**2**) + (6 AND**2**) = 1 + 1 + 0 + 2 = 4`` 。    


请你返回将 ``nums`` 中所有数放入``numSlots`` 个篮子中的最大与和。



**示例 1：**

```
输入：nums = [1,2,3,4,5,6], numSlots = 3
输出：9
解释：一个可行的方案是 [1, 4] 放入篮子 1 中，[2, 6] 放入篮子 2 中，[3, 5] 放入篮子 3 中。
最大与和为 (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9 。
```

**示例 2：**

```
输入：nums = [1,3,10,4,7,1], numSlots = 9
输出：24
解释：一个可行的方案是 [1, 1] 放入篮子 1 中，[3] 放入篮子 3 中，[4] 放入篮子 4 中，[7] 放入篮子 7 中，[10] 放入篮子 9 中
。
最大与和为 (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24 。       
注意，篮子 2 ，5 ，6 和 8 是空的，这是允许的。
```



**提示：**


- ``n == nums.length``
- ``1 <= numSlots <= 9``
- ``1 <= n <= 2 * numSlots``
- ``1 <= nums[i] <= 15``



[LeetCode链接](https://leetcode-cn.com/problems/maximum-and-sum-of-array/)

### 思路及代码

记忆优化搜索，参考自 https://leetcode-cn.com/problems/maximum-and-sum-of-array/solution/zhuang-tai-ya-suo-dp-by-endlesscheng-5eqn/

这道题目是今天周赛的最后一题，没做出来。首先想到的做法是深度优先搜索，但是感觉会有较多的分支，复杂度过不去，就没有继续尝试。

看完别人的题解之后发现可以用记忆优化去做，但因为没有读懂题目的缘故，看题解也看的有点吃力。大佬给出的代码很简练，基本思路如下：

题目说明每个篮子可以放两个数字，实际上就等价于有 2m 个放数据的槽位，可以用 2m 个二进制位进行标识。如果该位置有数字，对应二进制位为1，如果没有数字对应二进制位为 0 ，根据本题目数据范围，可以直接使用整型表示。

> 以谁作为状态定义的对象呢？注意篮子编号是不能变的，而 nums 中元素的位置信息是不重要的。

在此基础上，使用数组 ``dp[i]`` 进行记录篮子使用情况为 i 时，放置 nums 中前 c 个数能组成的最大和，其中 c 为数字 i 中二进制 1 的个数。（因为最终的目标是计算所有数字均被摆放时的最大和，这里数据的先后放置顺序并不关键，经历多轮迭代后，数组中保存的便是指定篮子使用情况下的最大和。）

显然 dp[0] 为 0，将 nums[c] 放入篮子中时，查找当前状态下所有未使用的篮子，并尝试将 nums[c] 放入该位置 j，其对应的篮子编号为 $\frac{j}{2} + 1$ ，递推关系为：

$dp[i + 2^j] = max\{dp[i + 2^j], dp[i] + (\frac{j}{2} + 1 )\& nums[c] \}$

从零开始遍历 i 的所有可能值，并计算在该值下的最大和，最后统计二进制位个数为 n 时所有放置情况的最大和即可。

在进行代码实现时，需要注意位运算符的优先级。另外，上述编号方案比直接编号少了额外的判断，可以借鉴。

```cpp
class Solution {
public:
    int maximumANDSum(vector<int>& nums, int numSlots) {
        int m = numSlots * 2;   // 最大为18
        int n = nums.size();

        vector<int> dp(1 << m, 0);
        for(int i = 0; i < dp.size(); i++){
            int c = __builtin_popcount(i);
            if(c >= n)  continue;

            for(int j = 0; j < m; j++){
                int cur = 1 << j;
                if((i & cur) == 0){     // 注意优先级 位运算低于加减和 ==
                    int t = i | cur;
                    dp[t] = max(dp[t], dp[i] + ((j / 2 + 1) & nums[c]));
                }
            }
        }

        int res = 0;
        for(int i = 0; i < dp.size(); i++){
            if(__builtin_popcount(i) == n){
                res = max(res, dp[i]);
            }
        }
        return res;
    }
};
```

题目可以用最大费用流求解。